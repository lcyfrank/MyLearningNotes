> 通过提升速度来解决其他方式无法解决的问题是研究算法的设计和主要性能的主要原因之一

## 排序算法

> 排序算法最佳效果就是比较次数在 `O( lg(N!) ) ~ O( NlgN )` 之间，可以用二叉树的形式来证明

* **算法的稳定性：** 对于相同关键字的记录，排序前和排序后在数组中的位置不变，则该算法是稳定的，否则就是不稳定的。

[示例代码](./code/sort.c)

### 选择排序：

选择排序是最简单最直观的一种排序算法，它的思想如下：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再在剩下的元素中找到最小的元素，将它与第二个元素交换位置。如此往复，直到整个数组排序。

选择排序的特点：

* 运行时间和输入无关：一个已经有序的数组或主键全部相等的数组和一个元素随机排列的数组所用的排序时间相同
* 数据移动是最少的：选择排序的交换次数和数组的大小是线性关系，即交换次数为 `O(N)`，而其他的任何排序算法都不具备这个特点

### 插入排序：

对于每一个需要插入的元素，其余所有已经插入的元素需要向右移动为其腾出空间。即对于每一个将要插入的元素，从后向前遍历比较已经有序的元素，若被比较元素比当前元素大，则将被比较元素向后挪动一位，直到被比较元素比当前元素小或者相等，则在其后面插入该元素。

插入排序的特点：

* 对于已经部分有序的数组，插入排序的速度很快。若该数组基本有序，则插入排序的速度几乎可以是最快的

### 希尔排序：

针对插入排序的优化版本。对于大规模乱序数组，插入排序很慢，因为它只能一点一点地从数组的一端移动到另一端。希尔排序对其进行了改进，交换不相邻的元素以对数组进行局部排序，并最终对数组整体进行排序。

希尔排序的中心思想是 **使数组中任意间隔为 `h` 的元素都是有序的** 。这样可以使各个元素在排序几遍之后大致在最终位置的附近，减少了元素的挪动的次数，加快算法。

希尔排序的特点：

* 可以用于大型数组，对于任意排序的数组表现都很好，且不需要额外的内存空间
* 性能难以计算，但是可以明确的是 **它的运行时间达不到平方级别**

> 有经验的程序员会首先考虑选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的，而且代码量很小，并且不需要额外的内存空间。

### 归并排序：

> 归并：将两个有序的数组归并成一个更大的有序数组

将一个数组排序的时候，首先将它分成两半，进行分别排序，然后再将结果归并起来。

归并排序的特点：

* 能够保证任意长度为 `N` 的数组排序所需时间和 `NlogN` 成正比
* 主要缺点是所需的额外空间和 `N` 成正比

归并排序的一些　**优化方法** ：

* 由于归并排序使用递归算法，所以会使小规模问题中方法调用过于频繁。因为插入排序在处理小规模数组时效率较好，可以在处理小规模的子数组的时候使用插入排序（比如长度小于15时）。
* 可以在将数组合并之前，判断前一个数组的最后一个元素是否小于后一个数组的第一个元素，如果是，则说明此时数组已经有序，不必在进行额外的合并操作
* 可以节省将数组元素复制到辅助数组所用的时间

> 对于每一个算法，不要对算法初始实现的性能盖棺定论，最好的办法是先实现一个能想到的最简单的程序，当它成为瓶颈时再继续改进它。

*相应 [code](./code/sort.c) 文件夹中实现的是自顶向下法归并排序，实际上还有一种自底向上法*

自底向上法归并排序：先将整个数组两两合并，得到全部都是每两个有序的一个数组，然后再进行四四合并，在进行八八合并......知道最后合并成一个数组，则得到有序

### 快速排序：

快速排序适用于各种不同的输入数据，且在一般应用中比其他排序算法都要快得多。快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而使整个数组有序；快速排序将数组排序的方式是当子数组有序的时候，整个数组自然而然地也就有序了。

快速排序的特点：

* 原地排序，只需要一个很小的辅助栈
* 将长度为　`N`　的数组排序所需要的时间和　`NlgN` 成正比
* 快速排序非常脆弱，在实现时要非常小心才能避免低劣的性能
* 内循环足够短小，使得速度更快（归并排序和希尔排序比它慢的一个原因就是在内循环移动数据）

快速排序的切分方法：首选随意地取一个元素，然后从数组左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此交换它们的位置。如此往复。

快速排序的改进：

* 同大多数递归排序算法相同，对于小数组，快速排序比插入排序慢，因此在排序小数组的时候可以切换成插入排序
* 使用数组中一小部分元素的中位数来切分数组，这样可以使切分时的效果更好
* 使用三切分，将数组对应分为小于、等于和大于的三部分，但是编程实现起来比较复杂（在只有若干不同主键的随机数组中，三向切分的时间复杂度是线性的，三向切分最坏情况是所有主键均不相同）

### 堆排序：

> 现实中经常需要遇到处理类似优先队列的情况，即可以满足删除队列中优先级最高的元素和向队列中插入元素

#### 优先队列的简单实现

采用数组或者链表进行实现，可以分为两种：一种是在删除最大元素的时候遍历数组，找出最大的元素；另一种是在插入元素的时候使元素保持有序。但是这两种方法均需要使两个操作之一在最坏情况下均需要线性时间来完成。

#### 堆的介绍

在二叉堆中，每个元素都要保证大于等于另两个特定位置的元素。这些位置的元素又至少要大于等于数组中的另外两个元素。将所有元素画成一棵二叉树，则定义为： **当一棵二叉树的每个结点都大于等于它的两个子结点，则被称为堆有序** 。

**二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存。**

堆的有序化即将堆按照要求恢复状态，在有序化过程中，有两种状态：

* 当某个结点优先级上升时，我们需要由下至上恢复堆的顺序（例如向堆底增加一个元素）
* 当某个结点优先级降低时，我们需要由上至下恢复堆的顺序（例如将堆顶元素替换成一个小的元素）

堆排序就是借助于堆来进行排序。初始化的时候，先由数组初始化构造出一个堆（可以通过从右往左使用下沉法），然后在得到堆之后，选取堆顶元素，并从堆中移除，然后将堆中最后一个元素移至堆顶，再通过下沉法重新有序化堆，如此往复，从而完成排序。

堆排序的特点：

* 能够同时最优地利用空间和时间的方法，在最坏情况下也能保证使用 `2NlgN` 次比较和恒定的额外空间。

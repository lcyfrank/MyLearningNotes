> 通过提升速度来解决其他方式无法解决的问题是研究算法的设计和主要性能的主要原因之一

## 排序算法

> 排序算法最佳效果就是比较次数在 `O( lg(N!) ) ~ O( NlgN )` 之间，可以用二叉树的形式来证明

* **算法的稳定性：** 对于相同关键字的记录，排序前和排序后在数组中的位置不变，则该算法是稳定的，否则就是不稳定的。

[示例代码](./code/sort.c)

### 选择排序：

选择排序是最简单最直观的一种排序算法，它的思想如下：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再在剩下的元素中找到最小的元素，将它与第二个元素交换位置。如此往复，直到整个数组排序。

选择排序的特点：

* 运行时间和输入无关：一个已经有序的数组或主键全部相等的数组和一个元素随机排列的数组所用的排序时间相同
* 数据移动是最少的：选择排序的交换次数和数组的大小是线性关系，即交换次数为 `O(N)`，而其他的任何排序算法都不具备这个特点

### 插入排序：

对于每一个需要插入的元素，其余所有已经插入的元素需要向右移动为其腾出空间。即对于每一个将要插入的元素，从后向前遍历比较已经有序的元素，若被比较元素比当前元素大，则将被比较元素向后挪动一位，直到被比较元素比当前元素小或者相等，则在其后面插入该元素。

插入排序的特点：

* 对于已经部分有序的数组，插入排序的速度很快。若该数组基本有序，则插入排序的速度几乎可以是最快的

### 希尔排序：

针对插入排序的优化版本。对于大规模乱序数组，插入排序很慢，因为它只能一点一点地从数组的一端移动到另一端。希尔排序对其进行了改进，交换不相邻的元素以对数组进行局部排序，并最终对数组整体进行排序。

希尔排序的中心思想是 **使数组中任意间隔为 `h` 的元素都是有序的** 。这样可以使各个元素在排序几遍之后大致在最终位置的附近，减少了元素的挪动的次数，加快算法。

希尔排序的特点：

* 可以用于大型数组，对于任意排序的数组表现都很好，且不需要额外的内存空间
* 性能难以计算，但是可以明确的是 **它的运行时间达不到平方级别**

> 有经验的程序员会首先考虑选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的，而且代码量很小，并且不需要额外的内存空间。

### 归并排序

> 归并：将两个有序的数组归并成一个更大的有序数组

将一个数组排序的时候，首先将它分成两半，进行分别排序，然后再将结果归并起来。

归并排序的特点：

* 能够保证任意长度为 `N` 的数组排序所需时间和 `NlogN` 成正比
* 主要缺点是所需的额外空间和 `N` 成正比

归并排序的一些　**优化方法** ：

* 由于归并排序使用递归算法，所以会使小规模问题中方法调用过于频繁。因为插入排序在处理小规模数组时效率较好，可以在处理小规模的子数组的时候使用插入排序（比如长度小于15时）。
* 可以在将数组合并之前，判断前一个数组的最后一个元素是否小于后一个数组的第一个元素，如果是，则说明此时数组已经有序，不必在进行额外的合并操作
* 可以节省将数组元素复制到辅助数组所用的时间

> 对于每一个算法，不要对算法初始实现的性能盖棺定论，最好的办法是先实现一个能想到的最简单的程序，当它成为瓶颈时再继续改进它。

*相应 [code](./code/sort.c) 文件夹中实现的是自顶向下法归并排序，实际上还有一种自底向上法*

自底向上法归并排序：先将整个数组两两合并，得到全部都是每两个有序的一个数组，然后再进行四四合并，在进行八八合并......知道最后合并成一个数组，则得到有序

### 快速排序

快速排序适用于各种不同的输入数据，且在一般应用中比其他排序算法都要快得多。快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而使整个数组有序；快速排序将数组排序的方式是当子数组有序的时候，整个数组自然而然地也就有序了。

快速排序的特点：

* 原地排序，只需要一个很小的辅助栈
* 将长度为　`N`　的数组排序所需要的时间和　`NlgN` 成正比
* 快速排序非常脆弱，在实现时要非常小心才能避免低劣的性能
* 内循环足够短小，使得速度更快（归并排序和希尔排序比它慢的一个原因就是在内循环移动数据）

快速排序的切分方法：首选随意地取一个元素，然后从数组左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此交换它们的位置。如此往复。
